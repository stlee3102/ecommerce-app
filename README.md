# Project X

This is the final course project. Build a simple e-commerce application to support Wallymart's break in to the virtual space.

# Design overview

This project utilizes the model–view–controller (MVC) software design pattern.

## Design components

### Model

There are 3 database tables that we want to model our data over. Each of these tables are represented by a **record item** class to represent individual rows in the table, and a **database** class to support various database operations on the table. All data in the models are read from and written to disk as serialized Java objects. If files on disk does not exist or if data is invalid (serialize version not the same) the code will automatically start a fresh model.

<img src="https://github.com/stlee3102/ecommerce-app/blob/main/screenshots/chart1.png">

```mermaid
classDiagram
	class BaseDB {
		~String filename
		+initializeDB(dbFilename)$ BaseDB
		+flush()
	}

	BaseDB <|-- CustomerDB
	class CustomerDB {
		#int nextId
		~Collection~CustomerRecord~ customers
		+createCustomer(name) CustomerRecord
		+retrieveCustomer(id) CustomerRecord
		+retrieveCustomer(name) Collection~CustomerRecord~
		+updateCustomer(id) boolean
		+deleteCustomer(id)
	}
	
	CustomerDB "1" <-- "*" CustomerRecord
	class CustomerRecord {
		~int id
		~String name
		+getName() String
		+setName(name)
	}
  
	BaseDB <|-- InventoryDB
	class InventoryDB {
		#Collection~InventoryRecord~ inventory
		+createItem(name, description, sku, price) InventoryRecord
		+retrieveItemList() Collection~InventoryRecord~
		+retrieveItemByName(name) InventoryRecord
		+retrieveItemBySku(sku) InventoryRecord
		#updateItem(InventoryRecord, name, description, sku, price, stockQuantity)
		+updateItemByName(lookupName, name, description, sku, price, stockQuantity) boolean
		+updateItemBySku(lookupSku, name, description, sku, price, stockQuantity) boolean
		+deleteItemByName(name)
		+deleteItemBySku(sku)
	}
	
	InventoryDB "1" <-- "*"InventoryRecord
	class InventoryRecord {
    	#String name
    	#String description
    	#String sku
    	#double price
    	#int stockQuantity
    	+getName() String
    	+getDescription() String
    	+getSku() String
    	+getPrice() double
    	+getStockQuantity() int
    	+setStockQuantity(stockQuantity)
  	}

  	BaseDB <|-- OrderDB
  	class OrderDB {
	    ~Collection~OrderRecord~ orders
    	+createOrder(CustomerRecord, Collection~InventoryRecord~ items)
    	+retrieveOrder(orderId) OrderRecord
    	+retrieveAllOrders() Collection~OrderRecord~
    	+updateOrderProcessStatus(orderId, ProcessStatus) boolean
    	+updateOrderPaymentStatus(orderId, PaymentStatus) boolean
    	+deleteOrderPayment(orderId)
  	}

  	OrderDB "1" <-- "*"OrderRecord
  	class OrderRecord {
    	#int orderId
    	#int customerId
    	#Collection~InventoryRecord~ orderItems
    	#ProcessStatus processStatus
    	#PaymentStatus paymentStatus
    	+getProcessStatus() ProcessStatus
    	+canSetProcessStatus() boolean
    	+setProcessStatus(ProcessStatus)
    	+getPaymentStatus() PaymentStatus
    	+setPaymentStatus(PaymentStatus)
    	+getOrderId() int
    	+getCustomerId() int
    	+getOrderItems() Collection~InventoryRecord~
  	}

  	class ProcessStatus {
  		<<enumeration>>
  		NEW
  		PROCESSING
  		CLOSED
  		CANCELLED
  	}
  	OrderRecord --> ProcessStatus
	
  	class PaymentStatus {
	  	<<enumeration>>
  		NEW
  		PROCESSING
  		COMPLETE
    	REFUNDED
  	}
	OrderRecord --> PaymentStatus
```

#### Inventory Model (`InventoryDB` & `InventoryRecord`)

Keeps track of the available inventory the store has. Each record contains the following information:
* Item name
* Item description
* Item SKU (only visible internally for employees)
* Unit price
* Available stock quantity

##### Features

* Standard *create, retrieve, update, delete* operations are available.
* Record retrieval supports *fast* lookups by item name **or** by item SKU.
* Updates support updating any attributes on a given record.

#### Customer Model (`CustomerDB` & `CustomerRecord`)

Records the customer information. For the scope of this project, only the name of the customer is recorded in this model. Each record contains the following information:
* id (autogenerated by code, only used internally in the code)
* name

##### Features

* Standard *create, retrieve, update, delete* operations are available.
* Record retrieval supports lookups by id **or** name. Lookups by id are preferred (faster), by name is still possible (slower).

#### Order Model (`OrderDB` &` OrderRecord`)

Records the orders made in the system. Each record contains the following information:
* orderId (autogenerated by code)
* customerId (refers to a customer record id)
* processStatus (enum of status values)
* paymentStatus (enum of payment values)
* list of ordered items (sorted by item name)
 
##### Features

* Standard *create, retrieve, update, delete* operations are available.
* Updates are limited to the two status updates. All other attributes are immutable.

### View

The view is implemented using the Java Swing toolkit. There is also a text version of the UI, which can easily replace the graphical version by changing the instantiation of the initial screen class in the controller. For the scope of this document, only the graphical version is reviewed.
Since the Swing launches graphic elements on a separate thread, the `main` thread *waits* after launching each window. Once the UI window is complete (user finishes interacting in the window, e.g. clicks a button to advance to next window) the `main` thread *wakes* up to execute the next action (e.g. start the next window).

<img src="https://github.com/stlee3102/ecommerce-app/blob/main/screenshots/chart2.png">

```mermaid
classDiagram
	BaseScreen <|-- BaseSwingScreen
	BaseSwingScreen o-- ScreenResponseAction
	BaseSwingScreen <|-- UserSelectSwingScreen
	BaseSwingScreen <|-- EmployeeMainSwingScreen
	BaseSwingScreen <|-- EmployeeOrderDetailsSwingScreen
	BaseSwingScreen <|-- CustomerMainMenuSwingScreen
	BaseSwingScreen <|-- CustomerUserInfoSwingScreen
	BaseSwingScreen <|-- CustomerPaymentSwingScreen
	BaseSwingScreen <|-- CustomerThankYouSwingScreen

	class BaseScreen {
		#ProjectXController controller
		+initializeScreen()*
		+updateDisplay()*
		+waitForInput()* ScreenResponseAction
	}

	class ScreenResponseAction {
	  ~BaseScreen nextScreen
	  ~boolean flushToDb
	  ~boolean exitApp
	  +setNextScreen(BaseScreen)
	  +nextScreen() BaseScreen
	  +isFlushToDb() boolean
	  +setFlushToDb(boolean)
	  +isExitApp() boolean
	  +setExitApp(boolean)
	}
	
	class BaseSwingScreen {
	  -ScreenResponseAction response
	  -frame
	  #makeJFrame() JFrame
	  #makeActionableButton(buttonText, ActionListener) JButton
	  #getScreenResponseAction() ScreenResponseAction
	  #resumeMainThread()
	}
```

#### User Experience Flow

<img src="https://github.com/stlee3102/ecommerce-app/blob/main/screenshots/chart3.png">

```mermaid
graph TB
A[User Select] --> B[Employee Main Screen]
A --> D[Customer Main]
B --> C[Order Details]
C --> B
B --> A
D --> E[User Info]
E --> F[Make Payment]
F --> G[Thank You]
G --> D
G -- Refund --> H[Refund modal]
H --> D
```

#### User Select View (`UserSelectSwingScreen`)

<img align="right" src="screenshots/UserSelection.png" width="200"/>

Initial screen when the application starts. This screen is meant for the user to select their role, either *employee* or *customer*.
<br clear="right"/>

#### Employee Main View (`EmployeeMainSwingScreen`)

<img align="right" src="screenshots/EmployeeMain.png" width="400"/>

Displays a table of `orders` made in the system. Note that the table will be empty if no customers made any orders. Table data is immutable in this view, but the user can select individual rows and click on the `See details` button to operate on the order record.
<br clear="right"/>

#### Employee Order Details View (`EmployeeOrderDetailsSwingScreen`)

<img align="right" src="screenshots/EmployeeDetails.png" width="500"/>

Displays the order details selected from the previous screen. Details include a list of the items ordered and the total cost of the order. If the order is in a processing status where it can be updated, the employee can change the processing status of the order. Only processing status `NEW` and `PROCESSING` can be updated, all other status disable the update buttons.
<br clear="right"/>

#### Customer Main Menu View (`CustomerMainMenuSwingScreen`)

<img align="right" src="screenshots/CustomerMain.png" width="500"/>

Main screen presented to the customer. Includes a list of all inventory items, description, unit price and available stock. Customer can select the `In Cart` column for each item and change it to a number to *purchase* that item. The `Checkout` button will be clickable when at least one item is added to the cart, and the values are valid (non-negative, valid number, <= available stock).
<br clear="right"/>

#### Customer User Info View (`CustomerUserInfoSwingScreen`)

<img align="right" src="screenshots/CustomerUserInfo.png" width="300"/>

Customer can enter user info in this screen. For the scope of this project, only the customer's name is required. The `Make Payment` button is only enabled if there is *anything* typed into the name text field (i.e. non-empty).
<br clear="right"/>

#### Customer Payment View (`CustomerPaymentSwingScreen`)

<img align="right" src="screenshots/CustomerPayment.png" width="500"/>

Customer order summary and payment confirmation screen. For the scope of this project, the `Payment` button is always enabled and pressing it assumes successful payment.
<br clear="right"/>

#### Customer Thank You View (`CustomerThankYouSwingScreen`)

<img align="right" src="screenshots/CustomerThankyou.png" width="500"/>

Final `Thank You` screen for the customer to see. Contains the order summary **and** the order number generated upon a successful order. Customer is presented an option at this moment to *refund* the order by pressing the `Refund` button. Otherwise, customer can press the `Start new order` button to return back to the main customer screen.
<br clear="right"/>

### Other UI Notes

#### Refund notice (Modal dialog)

<img align="right" src="screenshots/CustomerRefunded.png" width="400"/>

Uses the built in modal dialog to inform that the order was refunded. Inventory and order databases updated to reflect the refunded item quantities and order payment status.
<br clear="right"/>

#### ScreenResponseAction (Supporting class)

Upon exiting each window, a `ScreenResponseAction` object gets created and populated with instructions for the controller to execute. Instructions may include:
* Launch a new view object (advance to another UI window)
* Flush DB data to disk
* Exit the application

### Controller

#### ProjectXController

The main loop and flow control logic is done in this class. Model and UI instantiation are all done within this controller class. Developer can easily switch UI implementation by switching the first screen assignment during initialization.
For demo purposes, if there is no data present, the controller will execute `populateDemoData` to populate some data.

<img src="https://github.com/stlee3102/ecommerce-app/blob/main/screenshots/chart4.png">

```mermaid
classDiagram
	ProjectXController *-- OrderInfo
	ProjectXController *-- PaymentProcessor
	ProjectXController *-- "*" BaseDB
	ProjectXController *-- "*" BaseScreen

	class ProjectXController {
		~CustomerDB customerDB
		~InventoryDB inventoryDB
		~OrderDB orderDB
		~OrderInfo currentCustomerOrderInfo
		~PaymentProcessor paymentProcessor
		~BaseScreen screen
		#initializeDBs()
		-populateDemoData()
		+getCustomerDB() CustomerDB
		+getInventoryDB() InventoryDB
		+getOrderDB() OrderDB
		+getCurrentOrderInfo() OrderInfo
		+processPayment() boolean
		+refundOrder(orderId)
		#flushDBs()
	}
	class OrderInfo {
	~Collection~InventoryRecord~ itemsInOrder
	~String customerName
	~OrderRecord finalizedOrderRecord
	+getCustomerName() customerName
	+setCustomerName(customerName)
	+getItemsInOrder() Collection~InventoryRecord~
	+getOrderId() orderId
	}
	class PaymentProcessor {
	+processOrderPayment() boolean
	+refundOrder(orderId)
	}
```

#### PaymentProcessor

This is a mock controller class to represent communications with a 3rd party payment library. For the scope of this project, all payments transactions are assumed to be successful. This class will update the internal `OrderDB` to reflect all payment transactions.

#### OrderInfo

Contains the *current session's* order info before committing the data to the DB classes. A typical customer session contains:
* Customer Info (name)
* List of items ordered
* Order Id once the order is committed

## Sequence diagram

### Employee flow

<img src="https://github.com/stlee3102/ecommerce-app/blob/main/screenshots/chart5.png">

```mermaid
sequenceDiagram
Employee ->> Main Screen: Select employee mode
activate Main Screen
Main Screen ->> OrderDB: Fetch orders
activate OrderDB
OrderDB -->> Main Screen: Return list of orders
deactivate OrderDB
Main Screen ->> Details Screen: Display order details
deactivate Main Screen
activate Details Screen
Details Screen ->> OrderDB: Fetch order details
activate OrderDB
OrderDB -->> Details Screen: Return order details
deactivate OrderDB
Employee ->> Details Screen: Change process status
Details Screen ->> OrderDB: Update process status for given order
Details Screen -->> Main Screen: Return to main screen
deactivate Details Screen
```

### Customer flow

<img src="https://github.com/stlee3102/ecommerce-app/blob/main/screenshots/chart6.png">

```mermaid
sequenceDiagram
Customer ->> Main Screen: Select customer mode
activate Main Screen
Main Screen ->> InventoryDB: Fetch inventory items
activate InventoryDB
InventoryDB -->> Main Screen: Return list of items
deactivate InventoryDB
Main Screen ->> User Info Screen: Enter user info
deactivate Main Screen
activate User Info Screen
User Info Screen ->> CustomerDB: Create new user
User Info Screen ->> Payment Screen: Prompt user to make payment
deactivate User Info Screen
activate Payment Screen
Payment Screen ->> Payment Processor: Send payment
activate Payment Processor
Payment Processor ->> OrderDB: Commit order
Payment Processor -->> Payment Screen: Payment success
deactivate Payment Processor
Payment Screen ->> Thank You Screen: Notify user successful payment
deactivate Payment Screen
activate Thank You Screen
Thank You Screen -->> Main Screen: End transaction, return to main screen for next order
deactivate Thank You Screen
```
## Conclusion
The application works as intended. I found it challenging to figure out what to implement, what not to implement, and how to most effectively structure the app in a model, view, controller format. For instance, additional features that could be implemented in the future are a full integration with a third party payment system, interface with an actual database, and additional features like product reviews. I ended up resolving the issues by using UML to organize my thoughts. The project was great to put into practice a lot of the subjects we learned in this class including GUI, serialization, and multi-threading.

## References
I used the Java Swing library to make the GUI. https://docs.oracle.com/javase/7/docs/api/javax/swing/package-summary.html

## Miscellaneous Notes
* This document was edited using [StackEdit.io](https://stackedit.io/).
* You can render UML diagrams using [Mermaid](https://mermaidjs.github.io/).
